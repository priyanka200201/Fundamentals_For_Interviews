Question 1: Why Sorting algorithms are important?
Answer:

Efficient sorting is important for optimizing the efficiency of other algorithms (such as search and merge algorithms) that require input data to be in sorted lists.
Sorting is also often useful for canonicalizing data and for producing human-readable output. 
Sorting have direct applications in database algorithms, divide and conquer methods, data structure algorithms, and many more.


Question 2: Classify Sorting Algorithms.
Answer:
Sorting algorithms can be categorised based on the following parameters:

1. Based on Number of Swaps or Inversion. This is the number of times the algorithm swaps elements to sort the input. Selection Sort requires the minimum number of swaps.

2. Based on Number of Comparisons. This is the number of times the algorithm compares elements to sort the input. Using Big-O notation,
the sorting algorithm examples listed above require at least O(n log n) comparisons in the best case and O(n2) comparisons in the worst case for most of the outputs.

3. Based on Recursion or Non-Recursion. Some sorting algorithms, such as Quick Sort, use recursive techniques to sort the input.
Other sorting algorithms, such as Selection Sort or Insertion Sort, use non-recursive techniques. 
Finally, some sorting algorithm, such as Merge Sort, make use of both recursive as well as non-recursive techniques to sort the input.

4. Based on Stability. Sorting algorithms are said to be stable if the algorithm maintains the relative order of elements with equal keys.
In other words, two equivalent elements remain in the same order in the sorted output as they were in the input.
Insertion sort, Merge Sort, and Bubble Sort are stable
Heap Sort and Quick Sort are not stable

5. Based on Extra Space Requirement. Sorting algorithms are said to be in place if they require a constant O(1) extra space for sorting.
Insertion sort and Quick-sort are in place sort as we move the elements about the pivot and do not actually use a separate array
which is NOT the case in merge sort where the size of the input must be allocated beforehand to store the output during the sort.
Merge Sort is an example of out place sort as it require extra memory space for it’s operations.


Question 3: Explain what is ideal Sorting algorithm?
Answer:

The Ideal Sorting Algorithm would have the following properties:

Stable: Equal keys aren’t reordered.
Operates in place: requiring O(1) extra space.
Worst-case O(n log n) key comparisons.
Worst-case O(n) swaps.
Adaptive: Speeds up to O(n) when data is nearly sorted or when there are few unique keys.
There is no algorithm that has all of these properties, and so the choice of sorting algorithm depends on the application.


Question 4: Explain how Bubble Sort works
Answer:
Bubble Sort is based on the idea of repeatedly comparing pairs of adjacent elements and then swapping their positions if they are in the wrong order. 
Bubble sort is a stable, in-place sort algorithm.

How it works:

In an unsorted array of n elements, start with the first two elements and sort them in ascending order. (Compare the element to check which one is greater).
Compare the second and third element to check which one is greater, and sort them in ascending order.
Compare the third and fourth element to check which one is greater, and sort them in ascending order.
Repeat steps 1–n until no more swaps are required.


Question 5: Explain how Insertion Sort works 
Answer
Insertion Sort is an in-place, stable, comparison-based sorting algorithm. The idea is to maintain a sub-list which is always sorted.
An element which is to be 'insert'ed in this sorted sub-list, has to find its appropriate place and then it has to be inserted there. Hence the name, insertion sort.

Steps on how it works:

If it is the first element, it is already sorted.
Pick the next element.
Compare with all the elements in sorted sub-list.
Shift all the the elements in sorted sub-list that is greater than the value to be sorted.
Insert the value.
Repeat until list is sorted.
